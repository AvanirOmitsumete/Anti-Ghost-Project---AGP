{
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the provided Text/Code and complete the task outlined below. Your output MUST be formatted for maximum readability and structured for easy data parsing:\nFormatting Rules:\n- Start your response with a $\\text{HEADING}$ summarizing the key result.\n- Use $\\text{BULLET POINTS}$ for all primary findings, details, or steps.\n- $\\text{BOLD}$ all key terms and final conclusions.\n- Conclude the response with a separate, strictly a single line providing your confidence score—where <=50 is the image is AI generated, 51-80 is human + AI Generated, 81-89 mostly human, and 90-100 is full human—in the strict format: $\\text{CONFIDENCE: } [x/100]$ where $[x]$ is an integer from 1 to 100.\n\nIdentify the Text/Code if it is generated by AI or Not: \nhttps://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Text/Code HTTP Request').item.json.Key }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        368,
        368
      ],
      "id": "bec06f38-2d8f-45a6-967b-aace8a3c4e68",
      "name": "Text/Code AI Agent"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the provided document and complete the task outlined below. Your output MUST be formatted for maximum readability and structured for easy data parsing:\nFormatting Rules:\n- Start your response with a $\\text{HEADING}$ summarizing the key result.\n- Use $\\text{BULLET POINTS}$ for all primary findings, details, or steps.\n- $\\text{BOLD}$ all key terms and final conclusions.\n- Conclude the response with a separate, strictly a single line providing your confidence score—where <=50 is the image is AI generated, 51-80 is human + AI Generated, 81-89 mostly human, and 90-100 is full human—in the strict format: $\\text{CONFIDENCE: } [x/100]$ where $[x]$ is an integer from 1 to 100.\n\nIdentify the document if it is generated by AI or Not: \nhttps://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Document HTTP Request').item.json.Key }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        368,
        640
      ],
      "id": "0e1c06f3-52de-4f27-874a-84ac12ea7d47",
      "name": "Document AI Agent"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the provided video and complete the task outlined below. Your output MUST be formatted for maximum readability and structured for easy data parsing:\nFormatting Rules:\n- Start your response with a $\\text{HEADING}$ summarizing the key result.\n- Use $\\text{BULLET POINTS}$ for all primary findings, details, or steps.\n- $\\text{BOLD}$ all key terms and final conclusions.\n- Conclude the response with a separate, strictly a single line providing your confidence score—where <=50 is the image is AI generated, 51-80 is human + AI Generated, 81-89 mostly human, and 90-100 is full human—in the strict format: $\\text{CONFIDENCE: } [x/100]$ where $[x]$ is an integer from 1 to 100.\n\nIdentify the video if it is generated by AI or Not: \nhttps://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Video HTTP Request').item.json.Key }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        368,
        928
      ],
      "id": "3124a58d-a64b-4cc7-9ab2-613ba767d174",
      "name": "Video AI Agent"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        400,
        240
      ],
      "id": "7d659119-b4bb-446d-819c-47496149e365",
      "name": "Image AI Checker",
      "credentials": {
        "googlePalmApi": {
          "id": "wTaEiHXVH9J6js4R",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        400,
        496
      ],
      "id": "cb77d681-7186-44d0-be3f-163e683479ee",
      "name": "Text/Code AI Checker",
      "credentials": {
        "googlePalmApi": {
          "id": "wTaEiHXVH9J6js4R",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        400,
        784
      ],
      "id": "860cc168-55fb-48e1-91df-6c1f1fdc0de4",
      "name": "Document AI Checker",
      "credentials": {
        "googlePalmApi": {
          "id": "wTaEiHXVH9J6js4R",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        400,
        1072
      ],
      "id": "d63c7194-e684-4895-b0aa-186bf6e0413e",
      "name": "Video AI Checker",
      "credentials": {
        "googlePalmApi": {
          "id": "wTaEiHXVH9J6js4R",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/image_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "File",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        80,
        96
      ],
      "id": "8241fc1e-fa4b-4c71-9c9d-729a460028c6",
      "name": "Image HTTP Request",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/text_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "File",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        80,
        368
      ],
      "id": "ca0b1e96-978a-4bc1-a220-8bb124b70f8f",
      "name": "Text/Code HTTP Request",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/document_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "File",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        80,
        640
      ],
      "id": "f2200f18-d253-40cb-baf8-bacbd7481779",
      "name": "Document HTTP Request",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/video_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "File",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        80,
        928
      ],
      "id": "efb5b4f5-e5f3-4f40-89dd-197bca2ddda8",
      "name": "Video HTTP Request",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "ai_file_registries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "file_name",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileName }}"
            },
            {
              "fieldId": "file_category",
              "fieldValue": "={{ $('File Extension Switch').item.json.File_fileCategory }}"
            },
            {
              "fieldId": "mime_type",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            },
            {
              "fieldId": "size_bytes",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileSize }}"
            },
            {
              "fieldId": "storage_bucket",
              "fieldValue": "image_bucket"
            },
            {
              "fieldId": "storage_path",
              "fieldValue": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Image HTTP Request').item.json.Key }}"
            },
            {
              "fieldId": "ai_agent_status",
              "fieldValue": "COMPLETED"
            },
            {
              "fieldId": "ai_agent_result",
              "fieldValue": "={{ $('Image AI Agent').item.json.output }}"
            },
            {
              "fieldId": "confidence_score",
              "fieldValue": "={{ $('Extractor1').item.json.confidence_score }}"
            },
            {
              "fieldId": "project_id",
              "fieldValue": "={{ $('AI File Validator Webhook').item.json.body.project_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1168,
        96
      ],
      "id": "96b878b0-77d8-4c78-9605-65f372c3ee1c",
      "name": "Image Path Supabase",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "ai_file_registries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "file_name",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileName }}"
            },
            {
              "fieldId": "file_category",
              "fieldValue": "={{ $('File Extension Switch').item.json.File_fileCategory }}"
            },
            {
              "fieldId": "mime_type",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            },
            {
              "fieldId": "size_bytes",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileSize }}"
            },
            {
              "fieldId": "storage_bucket",
              "fieldValue": "text_bucket"
            },
            {
              "fieldId": "storage_path",
              "fieldValue": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Text/Code HTTP Request').item.json.Key }}"
            },
            {
              "fieldId": "ai_agent_status",
              "fieldValue": "Completed"
            },
            {
              "fieldId": "ai_agent_result",
              "fieldValue": "={{ $('Text/Code AI Agent').item.json.output }}"
            },
            {
              "fieldId": "confidence_score",
              "fieldValue": "={{ $('Extractor2').item.json.confidence_score }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1168,
        368
      ],
      "id": "c3cad5ed-3da3-4aa2-b8e9-2e0c765a5726",
      "name": "Text/Code Path Supabase",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "ai_file_registries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "file_name",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileName }}"
            },
            {
              "fieldId": "file_category",
              "fieldValue": "={{ $('File Extension Switch').item.json.File_fileCategory }}"
            },
            {
              "fieldId": "mime_type",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            },
            {
              "fieldId": "size_bytes",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileSize }}"
            },
            {
              "fieldId": "storage_bucket",
              "fieldValue": "document_bucket"
            },
            {
              "fieldId": "storage_path",
              "fieldValue": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Document HTTP Request').item.json.Key }}"
            },
            {
              "fieldId": "ai_agent_status",
              "fieldValue": "Completed"
            },
            {
              "fieldId": "ai_agent_result",
              "fieldValue": "={{ $('Document AI Agent').item.json.output }}"
            },
            {
              "fieldId": "confidence_score",
              "fieldValue": "={{ $('Extractor3').item.json.confidence_score }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1168,
        640
      ],
      "id": "8ee7cc2f-d78d-4080-b735-a6884b39533a",
      "name": "Document Path Supabase",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $execution.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        496,
        1072
      ],
      "id": "1f8d15f2-3adf-4186-a0f6-2cbb04fe3aa7",
      "name": "Video Simple Memory"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $execution.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        496,
        784
      ],
      "id": "4ab3f315-b7f3-4d9d-951e-f605bed6df20",
      "name": "Document Simple Memory"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $execution.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        496,
        240
      ],
      "id": "3c4a3ca8-11a7-46ab-865f-5791e53e2df1",
      "name": "Image Simple Memory"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $execution.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        496,
        496
      ],
      "id": "17693df9-6f66-4e8d-a58f-b57c720d04d8",
      "name": "Text/Code Simple Memory"
    },
    {
      "parameters": {
        "tableId": "ai_file_registries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "file_name",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileName }}"
            },
            {
              "fieldId": "file_category",
              "fieldValue": "={{ $('File Extension Switch').item.json.File_fileCategory }}"
            },
            {
              "fieldId": "mime_type",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.mimeType }}"
            },
            {
              "fieldId": "size_bytes",
              "fieldValue": "={{ $('File Extension Switch').item.binary.File.fileSize }}"
            },
            {
              "fieldId": "storage_bucket",
              "fieldValue": "video_bucket"
            },
            {
              "fieldId": "storage_path",
              "fieldValue": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Video HTTP Request').item.json.Key }}"
            },
            {
              "fieldId": "ai_agent_status",
              "fieldValue": "Completed"
            },
            {
              "fieldId": "ai_agent_result",
              "fieldValue": "={{ $('Video AI Agent').item.json.output }}"
            },
            {
              "fieldId": "confidence_score",
              "fieldValue": "={{ $('Extractor4').item.json.confidence_score }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1168,
        928
      ],
      "id": "4c5350f3-6aa5-419c-b4be-73f250aa9144",
      "name": "Video Path Supabase",
      "credentials": {
        "supabaseApi": {
          "id": "zS1pUqSyyDo51UC8",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "content": "## File Extension Filter",
        "height": 272,
        "width": 416
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -544,
        448
      ],
      "typeVersion": 1,
      "id": "75d055e8-d3f7-4c92-9dbd-498fa5634ce5",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "// --- 1. Define Extension Lists ---\nconst VIDEO_EXTENSIONS = ['mp4', 'webm', 'mov', 'avi', 'mkv', 'flv', 'wmv', '3gp'];\nconst TEXT_EXTENSIONS = ['txt', 'csv', 'json', 'log', 'md', 'xml', 'js', 'html', 'css'];\nconst IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'bmp', 'tiff', 'ico', 'heif', 'avif'];\nconst DOCUMENT_EXTENSIONS = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'];\n\n// --- 2. Helper Function to Get Extension ---\nfunction getFileExtension(filename) {\n    const lastDotIndex = filename.lastIndexOf('.');\n    if (lastDotIndex === -1 || lastDotIndex === filename.length - 1) {\n        return '';\n    }\n    return filename.substring(lastDotIndex + 1).toLowerCase();\n}\n\n// --- 3. Main Function to Process the n8n Input Array ---\nconst categorizedItems = [];\n\n// n8n function nodes process items one by one in a loop\nfor (const item of $input.all()) {\n    // Check if the item has binary data (which a webhook file upload will)\n    if (item.binary) {\n        const itemJson = item.json;\n        const itemBinary = item.binary;\n\n        // Iterate through all binary files attached to this item (e.g., if multiple files were uploaded)\n        for (const binaryKey in itemBinary) {\n            const binaryObject = itemBinary[binaryKey];\n            \n            // Get the filename from the binary data object\n            const filename = binaryObject.fileName; \n            const extension = getFileExtension(filename);\n            let category = 'Unknown';\n\n            // *** IF-ELSE-IF-ELSE Logic to assign the category ***\n            if (IMAGE_EXTENSIONS.includes(extension)) {\n                category = 'Image';\n            } else if (VIDEO_EXTENSIONS.includes(extension)) {\n                category = 'Video';\n            } else if (TEXT_EXTENSIONS.includes(extension)) {\n                category = 'Text/Code';\n            } else if (DOCUMENT_EXTENSIONS.includes(extension)) {\n                category = 'Document';\n            } else if (extension === 'zip' || extension === 'rar' || extension === '7z') {\n                category = 'Archive';\n            } else if (extension === '') {\n                category = 'No Extension';\n            } else {\n                category = 'Other';\n            }\n\n            // Add the new category property to the item's JSON data\n            // We use the binaryKey (e.g., 'data') to know which file this category belongs to.\n            itemJson[`${binaryKey}_fileCategory`] = category;\n            \n            // Optional: Log to the console for debugging in n8n\n            console.log(`Processed file: ${filename}, Category: ${category}`);\n        }\n        \n        // Push the modified item (with the new category in its JSON) to the output\n        categorizedItems.push(item);\n\n    } else {\n        // Handle items without binary data (e.g., simple form data)\n        categorizedItems.push(item);\n    }\n}\n\nreturn categorizedItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        528
      ],
      "id": "7b4ebaae-624f-48aa-96a1-0900677473c1",
      "name": "getFileExtension",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.File_fileCategory }}",
                    "rightValue": "Image",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "fd27c41f-c6d3-45ec-9c1f-d7ebae83abf3"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "eeea5aac-0e13-4f9f-8590-c081a67db829",
                    "leftValue": "={{ $json.File_fileCategory }}",
                    "rightValue": "Text/Code",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "3b0f65a5-c6a7-4f10-a716-2ae19c3ea381",
                    "leftValue": "={{ $json.File_fileCategory }}",
                    "rightValue": "Document",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f57918c7-71ce-4829-b35c-06740f135c73",
                    "leftValue": "={{ $json.File_fileCategory }}",
                    "rightValue": "Video",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -288,
        496
      ],
      "id": "097664fe-de8b-4755-b817-cc07004d6f50",
      "name": "File Extension Switch"
    },
    {
      "parameters": {
        "content": "## Post Files to the Supabase bucket",
        "height": 1072
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "4d17325f-a02b-42ff-94b4-a52c847cc867",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "## Post the data to Supabase",
        "height": 1104,
        "width": 224
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1104,
        0
      ],
      "typeVersion": 1,
      "id": "379d850f-af90-487f-a5a4-5880ee918d13",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-file-validator",
        "responseMode": "lastNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -768,
        528
      ],
      "id": "f55c14e6-6496-4894-b6f0-cc148c7a27bc",
      "name": "AI File Validator Webhook",
      "webhookId": "7d14df81-ef1a-488a-9c25-9339b9ea5b07"
    },
    {
      "parameters": {
        "content": "## Confident Score Extractor",
        "height": 1104
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        736,
        0
      ],
      "typeVersion": 1,
      "id": "ea256cd0-e2de-4862-a8e5-8b77c51fcfab",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Final attempt: Extracts the confidence score using a simple, non-greedy regex\n * that only looks for the number/100 pattern.\n */\nfunction extractConfidenceScore() {\n    // 1. ACCESS & CLEAN: The 'data' field is confirmed to hold the text.\n    // Use String().trim() to clean up all surrounding whitespace/newlines.\n    const rawAnalysis = $input.first().json.output ? String($input.first().json.output).trim() : null; \n    \n    let confidenceScore = null;\n    let confidenceDecimal = null;\n    let error = null;\n\n    if (!rawAnalysis) {\n        // Handle case where input field is completely empty.\n        error = \"Input field 'data' is empty or not a string.\";\n    } else {\n        // 2. REGEX: Look for ANY number (\\d+) followed by /100.\n        // This ignores the CONFIDENCE text, brackets, and LaTeX codes.\n        // It captures the number itself in group 1.\n        const confidenceScoreMatch = rawAnalysis.match(/(\\d+)\\/100/);\n\n        // 3. Process the match. The number we want is in capture group 1.\n        if (!confidenceScoreMatch || confidenceScoreMatch.length < 2) {\n            // The score was not found anywhere in the text.\n            error = \"FATAL: Could not find the pattern (number)/100 anywhere in the input.\";\n        } else {\n            // Success: captured number is at index 1.\n            confidenceScore = parseInt(confidenceScoreMatch[1], 10);\n            confidenceDecimal = confidenceScore / 100;\n        }\n    }\n\n    // 4. Return the result.\n    return [{\n        json: {\n            confidence_score: confidenceScore,\n            confidence_decimal: confidenceDecimal,\n            confidence_found: confidenceScore !== null,\n            // Include the first 75 characters of the raw text for final debugging\n            debug_raw_input_start: rawAnalysis ? rawAnalysis.substring(0, 75) : 'N/A',\n            error: error\n        }\n    }];\n}\n\n// Execute the function and return the result.\nreturn extractConfidenceScore();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        96
      ],
      "id": "7d5a3267-ecb3-432c-b39e-92eef5cb9f46",
      "name": "Extractor1"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Final attempt: Extracts the confidence score using a simple, non-greedy regex\n * that only looks for the number/100 pattern.\n */\nfunction extractConfidenceScore() {\n    // 1. ACCESS & CLEAN: The 'data' field is confirmed to hold the text.\n    // Use String().trim() to clean up all surrounding whitespace/newlines.\n    const rawAnalysis = $input.first().json.output ? String($input.first().json.output).trim() : null; \n    \n    let confidenceScore = null;\n    let confidenceDecimal = null;\n    let error = null;\n\n    if (!rawAnalysis) {\n        // Handle case where input field is completely empty.\n        error = \"Input field 'data' is empty or not a string.\";\n    } else {\n        // 2. REGEX: Look for ANY number (\\d+) followed by /100.\n        // This ignores the CONFIDENCE text, brackets, and LaTeX codes.\n        // It captures the number itself in group 1.\n        const confidenceScoreMatch = rawAnalysis.match(/(\\d+)\\/100/);\n\n        // 3. Process the match. The number we want is in capture group 1.\n        if (!confidenceScoreMatch || confidenceScoreMatch.length < 2) {\n            // The score was not found anywhere in the text.\n            error = \"FATAL: Could not find the pattern (number)/100 anywhere in the input.\";\n        } else {\n            // Success: captured number is at index 1.\n            confidenceScore = parseInt(confidenceScoreMatch[1], 10);\n            confidenceDecimal = confidenceScore / 100;\n        }\n    }\n\n    // 4. Return the result.\n    return [{\n        json: {\n            confidence_score: confidenceScore,\n            confidence_decimal: confidenceDecimal,\n            confidence_found: confidenceScore !== null,\n            // Include the first 75 characters of the raw text for final debugging\n            debug_raw_input_start: rawAnalysis ? rawAnalysis.substring(0, 75) : 'N/A',\n            error: error\n        }\n    }];\n}\n\n// Execute the function and return the result.\nreturn extractConfidenceScore();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        368
      ],
      "id": "3874cc8b-9f44-4bbb-9bef-c2be2643bc6a",
      "name": "Extractor2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Final attempt: Extracts the confidence score using a simple, non-greedy regex\n * that only looks for the number/100 pattern.\n */\nfunction extractConfidenceScore() {\n    // 1. ACCESS & CLEAN: The 'data' field is confirmed to hold the text.\n    // Use String().trim() to clean up all surrounding whitespace/newlines.\n    const rawAnalysis = $input.first().json.output ? String($input.first().json.output).trim() : null; \n    \n    let confidenceScore = null;\n    let confidenceDecimal = null;\n    let error = null;\n\n    if (!rawAnalysis) {\n        // Handle case where input field is completely empty.\n        error = \"Input field 'data' is empty or not a string.\";\n    } else {\n        // 2. REGEX: Look for ANY number (\\d+) followed by /100.\n        // This ignores the CONFIDENCE text, brackets, and LaTeX codes.\n        // It captures the number itself in group 1.\n        const confidenceScoreMatch = rawAnalysis.match(/(\\d+)\\/100/);\n\n        // 3. Process the match. The number we want is in capture group 1.\n        if (!confidenceScoreMatch || confidenceScoreMatch.length < 2) {\n            // The score was not found anywhere in the text.\n            error = \"FATAL: Could not find the pattern (number)/100 anywhere in the input.\";\n        } else {\n            // Success: captured number is at index 1.\n            confidenceScore = parseInt(confidenceScoreMatch[1], 10);\n            confidenceDecimal = confidenceScore / 100;\n        }\n    }\n\n    // 4. Return the result.\n    return [{\n        json: {\n            confidence_score: confidenceScore,\n            confidence_decimal: confidenceDecimal,\n            confidence_found: confidenceScore !== null,\n            // Include the first 75 characters of the raw text for final debugging\n            debug_raw_input_start: rawAnalysis ? rawAnalysis.substring(0, 75) : 'N/A',\n            error: error\n        }\n    }];\n}\n\n// Execute the function and return the result.\nreturn extractConfidenceScore();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        640
      ],
      "id": "b6831620-cb09-46af-9a04-6e50b9681b66",
      "name": "Extractor3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Final attempt: Extracts the confidence score using a simple, non-greedy regex\n * that only looks for the number/100 pattern.\n */\nfunction extractConfidenceScore() {\n    // 1. ACCESS & CLEAN: The 'data' field is confirmed to hold the text.\n    // Use String().trim() to clean up all surrounding whitespace/newlines.\n    const rawAnalysis = $input.first().json.output ? String($input.first().json.output).trim() : null; \n    \n    let confidenceScore = null;\n    let confidenceDecimal = null;\n    let error = null;\n\n    if (!rawAnalysis) {\n        // Handle case where input field is completely empty.\n        error = \"Input field 'data' is empty or not a string.\";\n    } else {\n        // 2. REGEX: Look for ANY number (\\d+) followed by /100.\n        // This ignores the CONFIDENCE text, brackets, and LaTeX codes.\n        // It captures the number itself in group 1.\n        const confidenceScoreMatch = rawAnalysis.match(/(\\d+)\\/100/);\n\n        // 3. Process the match. The number we want is in capture group 1.\n        if (!confidenceScoreMatch || confidenceScoreMatch.length < 2) {\n            // The score was not found anywhere in the text.\n            error = \"FATAL: Could not find the pattern (number)/100 anywhere in the input.\";\n        } else {\n            // Success: captured number is at index 1.\n            confidenceScore = parseInt(confidenceScoreMatch[1], 10);\n            confidenceDecimal = confidenceScore / 100;\n        }\n    }\n\n    // 4. Return the result.\n    return [{\n        json: {\n            confidence_score: confidenceScore,\n            confidence_decimal: confidenceDecimal,\n            confidence_found: confidenceScore !== null,\n            // Include the first 75 characters of the raw text for final debugging\n            debug_raw_input_start: rawAnalysis ? rawAnalysis.substring(0, 75) : 'N/A',\n            error: error\n        }\n    }];\n}\n\n// Execute the function and return the result.\nreturn extractConfidenceScore();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        928
      ],
      "id": "f246a439-1059-49b7-97e6-a108f630f191",
      "name": "Extractor4"
    },
    {
      "parameters": {
        "jsCode": "// This function hashes file data (Buffer/Data input)\nasync function hashFile(fileData) {\n    const crypto = require(`crypto`);\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(fileData);\n    return \"0x\" + hash.digest(\"hex\");\n}\n\n/**\n * Main function for the n8n Code node.\n * This node hashes a file, signs a proof-of-existence transaction,\n * and broadcasts it using Infura's JSON-RPC.\n */\nasync function generateProofTx() {\n    // --- 1. Get Inputs from Previous Nodes ---\n    const inputItem = $input.first();\n\n    // Accessing the binary file data and its name\n    // This assumes the binary data is on the key 'file'\n    const binaryData = inputItem.binary.file;\n    const fileName = binaryData ? binaryData.fileName : 'unknown_file';\n\n    if (!binaryData) {\n        throw new Error(\"File data is empty. Ensure the preceding node provides binary data under the key 'file'.\");\n    }\n\n    // --- 2. Get Credentials/Config from n8n Credentials ---\n    // 'ethers' and 'node-fetch' are external modules.\n    // Enable them in n8n's settings (see instructions below)\n    const { ethers } = require(\"ethers\");\n    const fetch = require(\"node-fetch\"); // Added for sending the tx\n\n    const privateKey = $input.first().json.PRIVATE_KEY;\n    const infuraProjectId = $input.first().json.INFURA_PROJECT_ID; // This should be just the ID, NOT the full URL.\n\n    // Basic validation for credentials\n    if (!privateKey || !infuraProjectId) {\n        throw new Error(\"PRIVATE_KEY and INFURA_PROJECT_ID must be present in your 'Web3 Credentials' n8n credential.\");\n    }\n\n    // --- 3. Transaction Logic ---\n    try {\n        const provider = new ethers.InfuraProvider(\"sepolia\", infuraProjectId);\n        const signer = new ethers.Wallet(privateKey, provider);\n\n        const network = await provider.getNetwork();\n        const chainId = network.chainId;\n\n        // Hash the file content\n        const fileHash = await hashFile(binaryData.data); // Use binaryData.data for the actual Buffer\n        console.log(\"Generated File Hash:\", fileHash);\n\n        const signature = await signer.signMessage(ethers.getBytes(fileHash));\n        const nonce = await provider.getTransactionCount(signer.address);\n        const transactionData = fileHash + signature.substring(2);\n\n        const transaction = {\n            to: signer.address, // Sending to self for proof of existence\n            value: ethers.parseEther(\"0\"),\n            nonce,\n            type: 2,\n            chainId,\n            gasLimit: 60000,\n            maxPriorityFeePerGas: ethers.parseUnits(\"1\", \"gwei\"),\n            maxFeePerGas: ethers.parseUnits(\"50\", \"gwei\"),\n            data: transactionData,\n        };\n\n        const signedTx = await signer.signTransaction(transaction);\n        console.log(\"Signed Transaction:\", signedTx);\n\n        // --- 4. Send the signed transaction to Infura (NEW PART) ---\n        const infuraUrl = infuraProjectId;\n        const jsonRpcPayload = {\n            jsonrpc: \"2.0\",\n            method: \"eth_sendRawTransaction\",\n            params: [signedTx],\n            id: 1,\n        };\n\n        console.log(`Sending raw transaction to Infura...`);\n\n        const response = await fetch(infuraUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(jsonRpcPayload),\n        });\n\n        const result = await response.json();\n\n        if (!response.ok || result.error) {\n            console.error(`Error sending transaction: ${response.status} - ${response.statusText}`);\n            console.error(\"Infura Response:\", result);\n            // Throw an error to make it visible in n8n\n            throw new Error(`Error from Infura: ${result.error ? result.error.message : 'Unknown error'}`);\n        }\n\n        const txHash = result.result;\n        console.log(\"Transaction sent successfully!\");\n        console.log(\"Transaction Hash:\", txHash);\n\n        // --- 5. Return Output ---\n        // Return the useful information for the next node.\n        const payload = {\n            filePath: fileName || \"proof_file\",\n            fileHash: fileHash,\n            signature,\n            signedTx,\n            transactionHash: txHash, // The new, important piece of data\n            etherscanUrl: `https://sepolia.etherscan.io/tx/${txHash}`\n        };\n\n        return [{ json: payload }];\n\n    } catch (error) {\n        // Catch and re-throw errors for better visibility in n8n\n        console.error(\"Error in transaction generation or sending:\", error);\n        throw new Error(`Error in transaction generation/sending: ${error.message}`);\n    }\n}\n\n// Execute the main function for the n8n Code node\nreturn generateProofTx();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        96
      ],
      "id": "528d080d-f3fd-4a2f-81b6-d55900aed723",
      "name": "Web 3 Image Transaction"
    },
    {
      "parameters": {
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/public/image_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        96
      ],
      "id": "1da78d74-cc89-45a8-81fc-ce1b13b2e92b",
      "name": "Get Image From Supabase"
    },
    {
      "parameters": {
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/public/text_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        368
      ],
      "id": "bbfe10b7-e108-473f-89ea-0657f2b9d24e",
      "name": "Get Text/Code From Supabase"
    },
    {
      "parameters": {
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/public/document_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        640
      ],
      "id": "b5c847eb-0792-4823-8aa5-3bbace6388a5",
      "name": "Get Document From Supabase"
    },
    {
      "parameters": {
        "url": "=https://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/public/video_bucket/{{ $('File Extension Switch').item.binary.File.fileName }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        928
      ],
      "id": "7135f215-ae26-4981-ac1c-6a0625fcf3b7",
      "name": "Get Video From Supabase"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0a4f0ec0-7881-407a-b0bc-3128221fb87a",
              "name": "PRIVATE_KEY",
              "value": "{{ credentials.metamask.network.private_key }}",
              "type": "string"
            },
            {
              "id": "2fdcc4f3-fd7d-425f-ba20-7608d3913a25",
              "name": "INFURA_PROJECT_ID",
              "value": "{{ credentials.infura.project_id }}",
              "type": "string"
            },
            {
              "id": "d8a6b006-5e60-4cb8-9000-f805f839291f",
              "name": "file",
              "value": "={{ $('Get Image From Supabase').item.binary.data }}",
              "type": "binary"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1712,
        96
      ],
      "id": "9c840b42-7fc4-4b6f-bdd1-d5e5c2670bad",
      "name": ".ENV.WEB1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0a4f0ec0-7881-407a-b0bc-3128221fb87a",
              "name": "PRIVATE_KEY",
              "value": "{{ credentials.metamask.network.private_key }}",
              "type": "string"
            },
            {
              "id": "2fdcc4f3-fd7d-425f-ba20-7608d3913a25",
              "name": "INFURA_PROJECT_ID",
              "value": "{{ credentials.infura.project_id }}",
              "type": "string"
            },
            {
              "id": "d8a6b006-5e60-4cb8-9000-f805f839291f",
              "name": "file",
              "value": "={{ $('Get Text/Code From Supabase').item.binary.data }}",
              "type": "binary"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1712,
        368
      ],
      "id": "4c011bef-84f2-472f-8a27-bf381f98e965",
      "name": ".ENV.WEB2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0a4f0ec0-7881-407a-b0bc-3128221fb87a",
              "name": "PRIVATE_KEY",
              "value": "{{ credentials.metamask.network.private_key }}",
              "type": "string"
            },
            {
              "id": "2fdcc4f3-fd7d-425f-ba20-7608d3913a25",
              "name": "INFURA_PROJECT_ID",
              "value": "{{ credentials.infura.project_id }}",
              "type": "string"
            },
            {
              "id": "d8a6b006-5e60-4cb8-9000-f805f839291f",
              "name": "file",
              "value": "={{ $('Get Document From Supabase').item.binary.data }}",
              "type": "binary"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1712,
        640
      ],
      "id": "bc293d29-1746-4512-bb11-52f6b1b6153f",
      "name": ".ENV.WEB3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0a4f0ec0-7881-407a-b0bc-3128221fb87a",
              "name": "PRIVATE_KEY",
              "value": "{{ credentials.metamask.network.private_key }}",
              "type": "string"
            },
            {
              "id": "2fdcc4f3-fd7d-425f-ba20-7608d3913a25",
              "name": "INFURA_PROJECT_ID",
              "value": "{{ credentials.infura.project_id }}",
              "type": "string"
            },
            {
              "id": "d8a6b006-5e60-4cb8-9000-f805f839291f",
              "name": "file",
              "value": "={{ $('Get Video From Supabase').item.binary.data }}",
              "type": "binary"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1712,
        928
      ],
      "id": "034a2452-5bdf-488a-8c4f-3af6bc4fbb07",
      "name": ".ENV.WEB4"
    },
    {
      "parameters": {
        "jsCode": "// This function hashes file data (Buffer/Data input)\nasync function hashFile(fileData) {\n    const crypto = require(`crypto`); // crypto is a built-in Node.js module\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(fileData);\n    return \"0x\" + hash.digest(\"hex\");\n}\n\n/**\n * Main function for the n8n Code node.\n * This node expects binary file data (e.g., from an HTTP Request node)\n * and JSON credentials (PRIVATE_KEY, INFURA_PROJECT_ID) from a preceding 'Edit Fields' node.\n */\nasync function generateProofTx() {\n    // --- 1. Get Inputs from Previous Nodes ---\n    const inputItem = $input.first();\n    const jsonInput = inputItem.json;\n\n    // Accessing the binary file data and its name\n    const binaryData = inputItem.binary.file;\n    const fileName = inputItem.binary.file.fileName;\n\n    if (!binaryData) {\n        throw new Error(\"File data is empty. Ensure the preceding node provides binary data under the key 'file'.\");\n    }\n\n    // --- 2. Get Credentials/Config from n8n Environment/JSON Input ---\n    // 'ethers' is an external module and must be enabled in n8n's settings (NODE_FUNCTION_ALLOW_EXTERNAL=*)\n    const { ethers } = require(\"ethers\");\n\n    // Credentials are pulled from the JSON output of the 'Edit Fields' node.\n    const privateKey = jsonInput.PRIVATE_KEY;\n    const infuraProjectId = jsonInput.INFURA_PROJECT_ID;\n\n    // Basic validation for credentials\n    if (!privateKey || !infuraProjectId) {\n        throw new Error(\"PRIVATE_KEY and INFURA_PROJECT_ID must be provided in the preceding 'Edit Fields' node.\");\n    }\n\n    // --- 3. Transaction Logic ---\n    try {\n        const provider = new ethers.InfuraProvider(\"sepolia\", infuraProjectId);\n        const signer = new ethers.Wallet(privateKey, provider);\n\n        const network = await provider.getNetwork();\n        const chainId = network.chainId;\n\n        // Hash the file content\n        const imageHash = await hashFile(binaryData.data); // Use binaryData.data for the actual Buffer\n        console.log(\"Generated Image Hash:\", imageHash);\n\n        const signature = await signer.signMessage(ethers.getBytes(imageHash));\n        const nonce = await provider.getTransactionCount(signer.address);\n        const transactionData = imageHash + signature.substring(2);\n\n        const transaction = {\n            to: signer.address, // Sending to self for proof of existence\n            value: ethers.parseEther(\"0\"),\n            nonce,\n            type: 2,\n            chainId,\n            gasLimit: 60000, // Adjust as needed\n            maxPriorityFeePerGas: ethers.parseUnits(\"1\", \"gwei\"),\n            maxFeePerGas: ethers.parseUnits(\"50\", \"gwei\"),\n            data: transactionData,\n        };\n\n        const signedTx = await signer.signTransaction(transaction);\n        console.log(\"Signed Transaction:\", signedTx);\n\n        // --- 4. Prepare Output for Next Node (e.g., HTTP Request to Infura) ---\n        const payload = {\n            filePath: fileName || \"proof_file\",\n            fileHash: imageHash,\n            signature,\n            signedTx\n        };\n\n        // --- 5. Return Output ---\n        // The output will be an array of objects, each with a 'json' property.\n        return [{ json: payload }];\n\n    } catch (error) {\n        // Catch and re-throw errors for better visibility in n8n\n        throw new Error(`Error in transaction generation: ${error.message}`);\n    }\n}\n\n// Execute the main function for the n8n Code node\nreturn generateProofTx();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        368
      ],
      "id": "e26f866d-23ef-4178-a60f-67a1105409d9",
      "name": "Web 3 Text/Code Transaction"
    },
    {
      "parameters": {
        "jsCode": "// This function hashes file data (Buffer/Data input)\nasync function hashFile(fileData) {\n    const crypto = require(`crypto`); // crypto is a built-in Node.js module\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(fileData);\n    return \"0x\" + hash.digest(\"hex\");\n}\n\n/**\n * Main function for the n8n Code node.\n * This node expects binary file data (e.g., from an HTTP Request node)\n * and JSON credentials (PRIVATE_KEY, INFURA_PROJECT_ID) from a preceding 'Edit Fields' node.\n */\nasync function generateProofTx() {\n    // --- 1. Get Inputs from Previous Nodes ---\n    const inputItem = $input.first();\n    const jsonInput = inputItem.json;\n\n    // Accessing the binary file data and its name\n    const binaryData = inputItem.binary.file;\n    const fileName = inputItem.binary.file.fileName;\n\n    if (!binaryData) {\n        throw new Error(\"File data is empty. Ensure the preceding node provides binary data under the key 'file'.\");\n    }\n\n    // --- 2. Get Credentials/Config from n8n Environment/JSON Input ---\n    // 'ethers' is an external module and must be enabled in n8n's settings (NODE_FUNCTION_ALLOW_EXTERNAL=*)\n    const { ethers } = require(\"ethers\");\n\n    // Credentials are pulled from the JSON output of the 'Edit Fields' node.\n    const privateKey = jsonInput.PRIVATE_KEY;\n    const infuraProjectId = jsonInput.INFURA_PROJECT_ID;\n\n    // Basic validation for credentials\n    if (!privateKey || !infuraProjectId) {\n        throw new Error(\"PRIVATE_KEY and INFURA_PROJECT_ID must be provided in the preceding 'Edit Fields' node.\");\n    }\n\n    // --- 3. Transaction Logic ---\n    try {\n        const provider = new ethers.InfuraProvider(\"sepolia\", infuraProjectId);\n        const signer = new ethers.Wallet(privateKey, provider);\n\n        const network = await provider.getNetwork();\n        const chainId = network.chainId;\n\n        // Hash the file content\n        const imageHash = await hashFile(binaryData.data); // Use binaryData.data for the actual Buffer\n        console.log(\"Generated Image Hash:\", imageHash);\n\n        const signature = await signer.signMessage(ethers.getBytes(imageHash));\n        const nonce = await provider.getTransactionCount(signer.address);\n        const transactionData = imageHash + signature.substring(2);\n\n        const transaction = {\n            to: signer.address, // Sending to self for proof of existence\n            value: ethers.parseEther(\"0\"),\n            nonce,\n            type: 2,\n            chainId,\n            gasLimit: 60000, // Adjust as needed\n            maxPriorityFeePerGas: ethers.parseUnits(\"1\", \"gwei\"),\n            maxFeePerGas: ethers.parseUnits(\"50\", \"gwei\"),\n            data: transactionData,\n        };\n\n        const signedTx = await signer.signTransaction(transaction);\n        console.log(\"Signed Transaction:\", signedTx);\n\n        // --- 4. Prepare Output for Next Node (e.g., HTTP Request to Infura) ---\n        const payload = {\n            filePath: fileName || \"proof_file\",\n            fileHash: imageHash,\n            signature,\n            signedTx\n        };\n\n        // --- 5. Return Output ---\n        // The output will be an array of objects, each with a 'json' property.\n        return [{ json: payload }];\n\n    } catch (error) {\n        // Catch and re-throw errors for better visibility in n8n\n        throw new Error(`Error in transaction generation: ${error.message}`);\n    }\n}\n\n// Execute the main function for the n8n Code node\nreturn generateProofTx();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        640
      ],
      "id": "79bf9c89-507e-4af5-9d0d-8d7847e0be8a",
      "name": "Web 3 Document Transaction"
    },
    {
      "parameters": {
        "jsCode": "// This function hashes file data (Buffer/Data input)\nasync function hashFile(fileData) {\n    const crypto = require(`crypto`); // crypto is a built-in Node.js module\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(fileData);\n    return \"0x\" + hash.digest(\"hex\");\n}\n\n/**\n * Main function for the n8n Code node.\n * This node expects binary file data (e.g., from an HTTP Request node)\n * and JSON credentials (PRIVATE_KEY, INFURA_PROJECT_ID) from a preceding 'Edit Fields' node.\n */\nasync function generateProofTx() {\n    // --- 1. Get Inputs from Previous Nodes ---\n    const inputItem = $input.first();\n    const jsonInput = inputItem.json;\n\n    // Accessing the binary file data and its name\n    const binaryData = inputItem.binary.file;\n    const fileName = inputItem.binary.file.fileName;\n\n    if (!binaryData) {\n        throw new Error(\"File data is empty. Ensure the preceding node provides binary data under the key 'file'.\");\n    }\n\n    // --- 2. Get Credentials/Config from n8n Environment/JSON Input ---\n    // 'ethers' is an external module and must be enabled in n8n's settings (NODE_FUNCTION_ALLOW_EXTERNAL=*)\n    const { ethers } = require(\"ethers\");\n\n    // Credentials are pulled from the JSON output of the 'Edit Fields' node.\n    const privateKey = jsonInput.PRIVATE_KEY;\n    const infuraProjectId = jsonInput.INFURA_PROJECT_ID;\n\n    // Basic validation for credentials\n    if (!privateKey || !infuraProjectId) {\n        throw new Error(\"PRIVATE_KEY and INFURA_PROJECT_ID must be provided in the preceding 'Edit Fields' node.\");\n    }\n\n    // --- 3. Transaction Logic ---\n    try {\n        const provider = new ethers.InfuraProvider(\"sepolia\", infuraProjectId);\n        const signer = new ethers.Wallet(privateKey, provider);\n\n        const network = await provider.getNetwork();\n        const chainId = network.chainId;\n\n        // Hash the file content\n        const imageHash = await hashFile(binaryData.data); // Use binaryData.data for the actual Buffer\n        console.log(\"Generated Image Hash:\", imageHash);\n\n        const signature = await signer.signMessage(ethers.getBytes(imageHash));\n        const nonce = await provider.getTransactionCount(signer.address);\n        const transactionData = imageHash + signature.substring(2);\n\n        const transaction = {\n            to: signer.address, // Sending to self for proof of existence\n            value: ethers.parseEther(\"0\"),\n            nonce,\n            type: 2,\n            chainId,\n            gasLimit: 60000, // Adjust as needed\n            maxPriorityFeePerGas: ethers.parseUnits(\"1\", \"gwei\"),\n            maxFeePerGas: ethers.parseUnits(\"50\", \"gwei\"),\n            data: transactionData,\n        };\n\n        const signedTx = await signer.signTransaction(transaction);\n        console.log(\"Signed Transaction:\", signedTx);\n\n        // --- 4. Prepare Output for Next Node (e.g., HTTP Request to Infura) ---\n        const payload = {\n            filePath: fileName || \"proof_file\",\n            fileHash: imageHash,\n            signature,\n            signedTx\n        };\n\n        // --- 5. Return Output ---\n        // The output will be an array of objects, each with a 'json' property.\n        return [{ json: payload }];\n\n    } catch (error) {\n        // Catch and re-throw errors for better visibility in n8n\n        throw new Error(`Error in transaction generation: ${error.message}`);\n    }\n}\n\n// Execute the main function for the n8n Code node\nreturn generateProofTx();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        928
      ],
      "id": "6ec4cffc-2fd8-4c8d-bb6e-f1d3a9718502",
      "name": "Web 3 Video Transaction"
    },
    {
      "parameters": {
        "content": "## File Validation with [Gemini](https://ai.google.dev)",
        "height": 1216,
        "width": 288
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        352,
        0
      ],
      "typeVersion": 1,
      "id": "b5032bfe-5cd7-4eac-9cf6-fe85c561df3e",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## POST Request\nWEBHOOK URL: http://13.229.247.66/webhook/ai-file-validator\n\nForm Data\nKey Name: File\nFile Limit: 25mb\n\nKey Name: project_id",
        "height": 208,
        "width": 352
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -976,
        304
      ],
      "id": "680b4b02-5b5e-4784-9ba8-16074eef746a",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "## Web 3 Interactions with: \n- infura.io\n- metamask.io - **Ethereum Sepolia Testnet**",
        "height": 1104,
        "width": 736
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1440,
        0
      ],
      "typeVersion": 1,
      "id": "10fcd981-40aa-4c0d-b500-91a72949ddfa",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the provided image and complete the task outlined below. Your output MUST be formatted for maximum readability and structured for easy data parsing:\nFormatting Rules:\n- Start your response with a $\\text{HEADING}$ summarizing the key result.\n- Use $\\text{BULLET POINTS}$ for all primary findings, details, or steps.\n- $\\text{BOLD}$ all key terms and final conclusions.\n- Conclude the response with a separate, strictly a single line providing your confidence score—where <=50 is the image is AI generated, 51-80 is human + AI Generated, 81-89 mostly human, and 90-100 is full human—in the strict format: $\\text{CONFIDENCE: } [x/100]$ where $[x]$ is an integer from 1 to 100.\n\nIdentify the image if it is generated by AI or Not: \nhttps://{{ credentials.supabase.id }}.supabase.co/storage/v1/object/{{ $('Image HTTP Request').item.json.Key }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        368,
        96
      ],
      "id": "43a5d8a7-c4cf-4b1b-a94d-e4e0197fc39f",
      "name": "Image AI Agent"
    },
    {
      "parameters": {
        "content": "## Extractor Code\n\n```\n/**\n * Extracts the confidence score using a simple, non-greedy regex\n * that only looks for the number/100 pattern.\n */\nfunction extractConfidenceScore() {\n    // 1. ACCESS & CLEAN: The 'data' field is confirmed to hold the text.\n    // Use String().trim() to clean up all surrounding whitespace/newlines.\n    const rawAnalysis = $input.first().json.output ? String($input.first().json.output).trim() : null; \n    \n    let confidenceScore = null;\n    let confidenceDecimal = null;\n    let error = null;\n    \n    if (!rawAnalysis) {\n        // Handle case where input field is completely empty.\n        error = \"Input field 'data' is empty or not a string.\";\n    } else {\n        // 2. REGEX: Look for ANY number (\\d+) followed by /100.\n        // This ignores the CONFIDENCE text, brackets, and LaTeX codes.\n        // It captures the number itself in group 1.\n        const confidenceScoreMatch = rawAnalysis.match(/(\\d+)\\/100/);\n        \n        // 3. Process the match. The number we want is in capture group 1.\n        if (!confidenceScoreMatch || confidenceScoreMatch.length < 2) {\n            // The score was not found anywhere in the text.\n            error = \"FATAL: Could not find the pattern (number)/100 anywhere in the input.\";\n        } else {\n            // Success: captured number is at index 1.\n            confidenceScore = parseInt(confidenceScoreMatch[1], 10);\n            confidenceDecimal = confidenceScore / 100;\n        }\n    }\n    \n    // 4. Return the result.\n    return [{\n        json: {\n            confidence_score: confidenceScore,\n            confidence_decimal: confidenceDecimal,\n            confidence_found: confidenceScore !== null,\n            // Include the first 75 characters of the raw text for final debugging\n            debug_raw_input_start: rawAnalysis ? rawAnalysis.substring(0, 75) : 'N/A',\n            error: error\n        }\n    }];\n}\n// Execute the function and return the result.\nreturn extractConfidenceScore();\n```",
        "height": 880,
        "width": 1024
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        2704,
        -608
      ],
      "typeVersion": 1,
      "id": "0c7cecff-cd2e-417d-ac7b-af41958af0e3",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "## WEB 3 Interaction Code\n\n```\n// This function hashes file data (Buffer/Data input)\nasync function hashFile(fileData) {\n    const crypto = require(`crypto`);\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(fileData);\n    return \"0x\" + hash.digest(\"hex\");\n}\n    \n/**\n * Main function for the n8n Code node.\n * This node hashes a file, signs a proof-of-existence transaction,\n * and broadcasts it using Infura's JSON-RPC.\n */\nasync function generateProofTx() {\n    // --- 1. Get Inputs from Previous Nodes ---\n    const inputItem = $input.first();\n    \n    // Accessing the binary file data and its name\n    // This assumes the binary data is on the key 'file'\n    const binaryData = inputItem.binary.file;\n    const fileName = binaryData ? binaryData.fileName : 'unknown_file';\n    \n    if (!binaryData) {\n        throw new Error(\"File data is empty. Ensure the preceding node provides binary data under the key 'file'.\");\n    }\n    \n    // --- 2. Get Credentials/Config from n8n Credentials ---\n    // 'ethers' and 'node-fetch' are external modules.\n    // Enable them in n8n's settings (see instructions below)\n    const { ethers } = require(\"ethers\");\n    const fetch = require(\"node-fetch\"); // Added for sending the tx\n    \n    const privateKey = $input.first().json.PRIVATE_KEY;\n    const infuraProjectId = $input.first().json.INFURA_PROJECT_ID; // This should be just the ID, NOT the full URL.\n    \n    // Basic validation for credentials\n    if (!privateKey || !infuraProjectId) {\n        throw new Error(\"PRIVATE_KEY and INFURA_PROJECT_ID must be present in your 'Web3 Credentials' n8n credential.\");\n    }\n    \n    // --- 3. Transaction Logic ---\n    try {\n        const provider = new ethers.InfuraProvider(\"sepolia\", infuraProjectId);\n        const signer = new ethers.Wallet(privateKey, provider);\n        \n        const network = await provider.getNetwork();\n        const chainId = network.chainId;\n        \n        // Hash the file content\n        const fileHash = await hashFile(binaryData.data); // Use binaryData.data for the actual Buffer\n        console.log(\"Generated File Hash:\", fileHash);\n        \n        const signature = await signer.signMessage(ethers.getBytes(fileHash));\n        const nonce = await provider.getTransactionCount(signer.address);\n        const transactionData = fileHash + signature.substring(2);\n        \n        const transaction = {\n            to: signer.address, // Sending to self for proof of existence\n            value: ethers.parseEther(\"0\"),\n            nonce,\n            type: 2,\n            chainId,\n            gasLimit: 60000,\n            maxPriorityFeePerGas: ethers.parseUnits(\"1\", \"gwei\"),\n            maxFeePerGas: ethers.parseUnits(\"50\", \"gwei\"),\n            data: transactionData,\n        };\n        \n        const signedTx = await signer.signTransaction(transaction);\n        console.log(\"Signed Transaction:\", signedTx);\n        \n        // --- 4. Send the signed transaction to Infura (NEW PART) ---\n        const infuraUrl = infuraProjectId;\n        const jsonRpcPayload = {\n            jsonrpc: \"2.0\",\n            method: \"eth_sendRawTransaction\",\n            params: [signedTx],\n            id: 1,\n        };\n        \n        console.log(`Sending raw transaction to Infura...`);\n        \n        const response = await fetch(infuraUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(jsonRpcPayload),\n        });\n        \n        const result = await response.json();\n        \n        if (!response.ok || result.error) {\n            console.error(`Error sending transaction: ${response.status} - ${response.statusText}`);\n            console.error(\"Infura Response:\", result);\n            // Throw an error to make it visible in n8n\n            throw new Error(`Error from Infura: ${result.error ? result.error.message : 'Unknown error'}`);\n        }\n        \n        const txHash = result.result;\n        console.log(\"Transaction sent successfully!\");\n        console.log(\"Transaction Hash:\", txHash);\n        \n        // --- 5. Return Output ---\n        // Return the useful information for the next node.\n        const payload = {\n            filePath: fileName || \"proof_file\",\n            fileHash: fileHash,\n            signature,\n            signedTx,\n            transactionHash: txHash, // The new, important piece of data\n            etherscanUrl: `https://sepolia.etherscan.io/tx/${txHash}`\n        };\n        \n        return [{ json: payload }];\n    \n    } catch (error) {\n        // Catch and re-throw errors for better visibility in n8n\n        console.error(\"Error in transaction generation or sending:\", error);\n        throw new Error(`Error in transaction generation/sending: ${error.message}`);\n    }\n}\n   \n// Execute the main function for the n8n Code node\nreturn generateProofTx();\n```",
        "height": 2096,
        "width": 1152
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3968,
        -624
      ],
      "typeVersion": 1,
      "id": "1a646760-0d8c-48d2-8d15-b4b95d3657df",
      "name": "Sticky Note8"
    }
  ],
  "connections": {
    "Text/Code AI Agent": {
      "main": [
        [
          {
            "node": "Extractor2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document AI Agent": {
      "main": [
        [
          {
            "node": "Extractor3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video AI Agent": {
      "main": [
        [
          {
            "node": "Extractor4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Image AI Checker": {
      "ai_languageModel": [
        [
          {
            "node": "Image AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Text/Code AI Checker": {
      "ai_languageModel": [
        [
          {
            "node": "Text/Code AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Document AI Checker": {
      "ai_languageModel": [
        [
          {
            "node": "Document AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Video AI Checker": {
      "ai_languageModel": [
        [
          {
            "node": "Video AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Image HTTP Request": {
      "main": [
        [
          {
            "node": "Image AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Text/Code HTTP Request": {
      "main": [
        [
          {
            "node": "Text/Code AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document HTTP Request": {
      "main": [
        [
          {
            "node": "Document AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video HTTP Request": {
      "main": [
        [
          {
            "node": "Video AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Image Path Supabase": {
      "main": [
        [
          {
            "node": "Get Image From Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Text/Code Path Supabase": {
      "main": [
        [
          {
            "node": "Get Text/Code From Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Path Supabase": {
      "main": [
        [
          {
            "node": "Get Document From Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Video Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "Video AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Document Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "Document AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Image Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "Image AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Text/Code Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "Text/Code AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Video Path Supabase": {
      "main": [
        [
          {
            "node": "Get Video From Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "getFileExtension": {
      "main": [
        [
          {
            "node": "File Extension Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Extension Switch": {
      "main": [
        [
          {
            "node": "Image HTTP Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Text/Code HTTP Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Document HTTP Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Video HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI File Validator Webhook": {
      "main": [
        [
          {
            "node": "getFileExtension",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extractor1": {
      "main": [
        [
          {
            "node": "Image Path Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extractor2": {
      "main": [
        [
          {
            "node": "Text/Code Path Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extractor3": {
      "main": [
        [
          {
            "node": "Document Path Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extractor4": {
      "main": [
        [
          {
            "node": "Video Path Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Image From Supabase": {
      "main": [
        [
          {
            "node": ".ENV.WEB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Text/Code From Supabase": {
      "main": [
        [
          {
            "node": ".ENV.WEB2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document From Supabase": {
      "main": [
        [
          {
            "node": ".ENV.WEB3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Video From Supabase": {
      "main": [
        [
          {
            "node": ".ENV.WEB4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    ".ENV.WEB1": {
      "main": [
        [
          {
            "node": "Web 3 Image Transaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    ".ENV.WEB2": {
      "main": [
        [
          {
            "node": "Web 3 Text/Code Transaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    ".ENV.WEB3": {
      "main": [
        [
          {
            "node": "Web 3 Document Transaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    ".ENV.WEB4": {
      "main": [
        [
          {
            "node": "Web 3 Video Transaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Image AI Agent": {
      "main": [
        [
          {
            "node": "Extractor1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bf192a9d61ad75486e7c11d38b123fd376a41cc106f1238a193619361a1ce84f"
  }
}